package main

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	ansi "github.com/mgutz/ansi"

	"github.com/komand/plugin-sdk-go2/dispatcher"
    plog "github.com/komand/plugin-sdk-go2/log"
	"github.com/komand/plugin-sdk-go2/message"

	{{- if .Actions }}
	"{{ .PackageRoot }}/actions"
	{{- end }}
	"{{ .PackageRoot }}/connection"
	"{{ .PackageRoot }}/server/http"
	{{- if .Triggers }}
	"{{ .PackageRoot }}/triggers"
	{{- end }}
)

var (
	// Name plugin name
	Name = "{{ .Name }}"
	// Vendor plugin vendor
	Vendor = "{{ .Vendor }}"
	// Version plugin version
    Version = "{{ .Version }}"
	// Description plugin description
    Description = "{{ .Description }}"
)

// These define various color constants 
var (
	lime  = ansi.ColorCode("green+h:black")
	red   = ansi.ColorCode("red")
	green = ansi.ColorCode("green")
	reset = ansi.ColorCode("reset")
)

type cliArgs struct {
	Command     string
	SubCommands []string
}

func getArgsFromCLI() (*cliArgs, error) {
	if len(os.Args) <= 1 {
		return nil, errors.New("you must specify command to invoke a plugin")
	}
	args := &cliArgs{
		Command:     os.Args[1],
		SubCommands: os.Args[2:],
	}
	return args, nil
}

func getMessageFromStdin() (*message.V1, *message.BodyV1, error) {
	b := &message.BodyV1{}
	m := &message.V1{
		Body:  b,// Seed it with a type so marshalling works
	}
	dec := json.NewDecoder(os.Stdin)
	if err := dec.Decode(m); err != nil {
		// Try from os.Args[3] which is where the ui plugin.test seems to send them
		// as well as triggers? Things from the engine don't seem to always use stdin
		if err := json.Unmarshal([]byte(os.Args[3]),m); err != nil {
			return nil, nil, err
		}
	}
	return m, b, nil
}

func pollSignals(cancel context.CancelFunc, c chan os.Signal) {
		<-c
		cancel()
		// Major hack - we should be blocking on a channel or series of channels that say
		// this part of the runtime has shut down, it's ok to proceed, then exit
		time.Sleep(1 * time.Second)
		os.Exit(0)
}

func main() {
	args, err := getArgsFromCLI()
	if err != nil {
		log.Fatal(err)
	}
	// Trap the interrupts
	stopChan := make(chan os.Signal, 1)
	signal.Notify(stopChan, syscall.SIGTERM, syscall.SIGINT)
	// Create a context, which will be used to cancel things like triggers in the event of a signal
	ctx, cancel := context.WithCancel(context.Background())
	// Kick off a goroutine to handle the signals and the cancellation
	go pollSignals(cancel, stopChan)
	// Invoke the command
	switch args.Command {
	case "version":
		printVersion()
	case "help":
		printHelp()
	case "info":
		printDescription()
	case "sample":
		if len(args.SubCommands) == 0 {
			log.Fatal("You must provide an action or trigger to generate sample input\nEx: sample my_action")
		}
		printSampleInput(args.SubCommands[0])
	case "http": // Daemonize as http
		s, err := http.NewServer(connection.NewCache())
		if err != nil {
			log.Fatal(err)
		}
		fmt.Println("Plugin {{ .Name }} booting HTTP Daemon...")
		// This will block until the server shuts down
		if err := s.ListenAndServe(); err != nil {
			log.Fatal(err)
		}
	case "run":
		fallthrough
	default:
		// We're running either an action, or a trigger
		m, b, err := getMessageFromStdin()
		if err != nil {
			log.Fatalf("you must provide a message body via STDIN to run an action or trigger: %s", err.Error())
		}
		switch m.Type {
		case "action_start":
			if err := runOneOffAction(args.Command, b); err != nil { // Command should be run, or test
				log.Fatal(err)
			}
		case "trigger_start":
			// This will block until the trigger shuts down
			if err := runTriggerDaemon(ctx, args.Command, b); err != nil { // Command should be run, or test
				log.Fatal(err)
			}
		default:
			log.Fatalf("unknown message type %s", m.Type)
		}
	}
}

func runOneOffAction(mode string, b *message.BodyV1) error {
	{{- if .Actions }}
	cd := &connection.Data{}
	l := plog.NewBufferedLogger()
	d, err := dispatcherFromRaw(b.Dispatcher)
	if err != nil {
		return err
	}
	defer l.Flush(os.Stderr)
	response := &message.Response{
		Meta: []byte(`{}`),
		Status: "ok",
	}
	if err := json.Unmarshal(b.Connection, cd); err != nil {
		return err
	}
	conn, err := connection.Connect(cd, l)
	if err != nil {
		return err
	}
	// Unmarshal the body into the right struct
	// We could avoid the 2 excess json marshal calls in here with a lot of switch-casing on types
	// but in this case, the performance gain is not that great, and it's less generator code to maintain
	// to do it this way.
	// TODO if we suspect this is a bottleneck, profile it and swap back to the switch-case approach
	switch b.Action {
	{{- range $n, $p := .Actions }}
	case "{{ $p.RawName }}":
		input := &actions.{{ $p.Name }}Input{}
		if err := json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		var err error
 		for _, err = range input.Validate() {
        	log.Println(fmt.Sprintf("Error while validating {{ .Name}}TriggerInput: %s", err.Error()))
   		}
   		if err != nil {
       		return fmt.Errorf("Error while validating {{ .Name}}TriggerInput. Check logs for details")
   		}
		a := &actions.{{ $p.Name }}Action{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
		response.Log = l.String()
		if err != nil {
			response.Status = "error"
			response.Error = err.Error()
		}
		// dispatch the result
		wrapper := &message.V1{
			Body: response,
			Type: "action_event",
			Version: "v1",
		}
		d.Send(wrapper)
	{{- end }}
	default:
		return fmt.Errorf("unknown action %s", b.Action)
	}
	{{- end}}
	return nil
}

func runTriggerDaemon(ctx context.Context, mode string, b *message.BodyV1) error {
	{{- if .Triggers }}
	// Make a logger
	l := plog.NewNormalLogger()
	// Serialize the connection data into the raw struct
	cd := &connection.Data{}
	if err := json.Unmarshal(b.Connection, cd); err != nil {
		return err
	}
	// Now, establish a valid connection
	conn, err := connection.Connect(cd, l)
	if err != nil {
		return err
	}
	// Get the dispatcher - will send the messages be sent over stdout or posted over http
	d, err := dispatcherFromRaw(b.Dispatcher)
	if err != nil {
		return err
	}
	// Serialize the meta data about the trigger into the meta struct
	meta := message.TriggerEventMeta{}
	if err := json.Unmarshal(b.Meta, &meta); err != nil {
		return err
	}
	switch b.Trigger {
	{{- range $n, $p := .Triggers }}
	case "{{ $p.RawName }}":
		// Make the input and serialize it into the struct
		input := &triggers.{{ .Name }}TriggerInput{}
		if err := json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		// Build the trigger
		t := triggers.New{{ $p.Name }}Trigger(d, meta)
		if mode == "test" { // Test mode, use the test method
			// Since the test method doesn't need a run or read loop
			// we do the boring work of packaging the result here
			// Invoke the test, pass the results to the message helper func
			// then pass that message into the dispatcher
			o, err := t.Test(conn, input, l)
			d.Send(testResultMessage(l, o, err))
			return nil
		}
		// Start the read loop
		go t.ReadLoop(ctx, l)
		// Run will block until it completes / shutsdown
		return t.RunLoop(ctx, conn, input, l)
	{{- end }}
	default:
		return fmt.Errorf("unknown trigger %s", b.Trigger)
	}
	{{- end}}
	{{- if not .Triggers }}
	return nil
	{{- end}}
}

func testResultMessage(log plog.Logger, o interface{}, err error) *message.V1 {
	l := ""
	if blog, ok := log.(*plog.BufferedLogger); ok {
		l = blog.String()
	}
	response := &message.Response{
		Meta: []byte(`{}`),
		Output: o,
		Status: "ok",
		Log: l,
	}
	if  err != nil {
		response.Error = err.Error()
		response.Status = "error"
	}
	wrapper := &message.V1{
		Body: response,
		Type: "trigger_event",
		Version: "v1",
	}
	return wrapper
}

// This is pretty hacky, not sure if there is a better way but from the engine, it doesn't look
// like we send any kind of "type" flag with the dispatcher... it looks like what we do is default
// to a certain type, and replace it only in certain hardcoded instances. So, the old approach is a pain
// and the new approach is a pain. I'm calling this a lateral change at best until proven otherwise
func dispatcherFromRaw(data json.RawMessage) (dispatcher.Dispatcher, error) {
	m := make(map[string]interface{})
	if err := json.Unmarshal(data, &m); err != nil {
		return nil, err
	}
	if url, ok := m["url"]; ok { // Engine actually sends 2 values, but we only use this one?
		return dispatcher.NewHTTP(url.(string)), nil
	}
	return dispatcher.NewStdout(), nil
}

func printDescription() {
	// General Info / Header
	result := "\n"
	result += fmt.Sprintf("Name:        %s%s%s✨\n", green, Name, reset)
	result += fmt.Sprintf("Vendor:      %s%s%s✨\n", green, Vendor, reset)
	result += fmt.Sprintf("Version:     %s%s%s✨\n", green, Version, reset)
	result += fmt.Sprintf("Description: %s%s%s✨\n", green, Description, reset)

	{{- if .Triggers }}
	{{ $trigcount := (len .Triggers) }}
	// Trigger Info
	result += fmt.Sprintf("\n")
	result += fmt.Sprintf("Triggers (%s%d%s): \n", green, {{- $trigcount }}, reset)
	{{- range $i, $t := .Triggers }}
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", green, "{{- $t.Name }}", reset, "{{- $t.Description }}", reset)
	{{- end }}
	{{- end }}

	{{- if .Actions }}
	{{ $actioncount := (len .Actions) }}
	// Action Info
	result += fmt.Sprintf("\n")
	result += fmt.Sprintf("Actions (%s%d%s): \n", green, {{ $actioncount }}, reset)
	{{- range $i, $a := .Actions }}
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", green, "{{- $a.Name }}", reset, "{{- $a.Description }}", reset)
	{{- end }}
	{{- end }}

	fmt.Print(result)
}

func printSampleInput(action string) error {
	connBytes, err := json.Marshal(connection.Data{})
	if err != nil {
		return err
	}
	b := &message.BodyV1{
		Action: action,
		Connection: connBytes,
		Meta: []byte(`{}`),
		Dispatcher: []byte(`{}`),
	}
	m := message.V1{
		Version: "v1",
		Body: b,
	}
	switch action {
	{{- range $i, $a := .Actions }}
	case "{{ $a.RawName }}":
		m.Type = "action_event"
		actionBytes, err := json.Marshal(actions.{{ $a.Name }}Input{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	{{- end}}
	{{- range $i, $t := .Triggers }}
	case "{{ $t.RawName }}":
		m.Type = "trigger_event"
		triggerBytes, err := json.Marshal(triggers.{{ $t.Name }}TriggerInput{})
		if err != nil {
			return err
		}
		b.Input = triggerBytes
	{{- end}}
	default:
		log.Fatalf("Unknown action or trigger %s", action)
	}

	result, err := json.MarshalIndent(&m, " ", "  ")
	if err != nil {
		return err
	}
	fmt.Println(string(result))
	return nil
}

func printVersion() {
	fmt.Println(Version)
}

func printHelp() {
	fmt.Print("{{ .Name}} Help:\n\n")
	fmt.Print("Commands:\n\n")
	fmt.Print("help:\n\tShows this menu\n\n")
	fmt.Print("version:\n\tDisplay version info\n\n")
	fmt.Print("info:\n\tDisplay information about the available actions and triggers, as well as general plugin metadata\n\n")
	fmt.Print("sample <trigger or action name>:\n\tDisplay a sample input message for the defined trigger or action\n\n")
	fmt.Print("test:\n\tRun the test method associated with the provided trigger or action specified via an input message over stdin\n\n")
	fmt.Print("run:\n\tRun the run method associated with the provided trigger or action specified via an input message over stdin\n\n")
}