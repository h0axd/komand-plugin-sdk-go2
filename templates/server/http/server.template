package http

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
	"net/http"
	"time"

	"{{ .PackageRoot }}/connection"
	"github.com/komand/plugin-sdk-go2/message"
)

// NewServer returns a new http server
func NewServer(port int, c *connection.Cache) (*http.Server, error) {
	// TODO each plugin needs a unique port to expose
	// but internally, can all use a common port
	addr := fmt.Sprintf(":%d",port)
	// TODO make these configurable somehow
	readTimeout := time.Second * time.Duration({{ .HTTP.ReadTimeout}})
	writeTimeout := time.Second * time.Duration({{ .HTTP.WriteTimeout}})

	mux := http.NewServeMux()
    // one for each action
    {{- range $n, $p := .Actions }}
    mux.Handle("/actions/{{ $p.RawName }}", New{{ $p.Name}}Handler(c))
	mux.Handle("/actions/{{ $p.RawName }}/test", New{{ $p.Name}}Handler(c))
    {{- end }}

	{{- range $n, $p := .Triggers }}
    mux.Handle("/triggers/{{ $p.RawName }}/test", New{{ $p.Name}}TriggerHandler(c))
    {{- end }}

	s := &http.Server{
		Addr:           addr,
		Handler:        mux,
		ReadTimeout:    readTimeout,
		WriteTimeout:   writeTimeout,
		MaxHeaderBytes: 1 << 20,
	}
	return s, nil
}

// Light wrapper around returning an error with the response object over http
func replyWithError(response *message.Response, w http.ResponseWriter, responseType string, err error) {
	response.Error = err.Error()
	response.Status = "error"
	m := &message.V1{
		Body: response,
		Type: responseType,
		Version: "v1",
	}
	b, _ := json.Marshal(m) // There is nothing we can do if this fails?
	w.Write(b)
}