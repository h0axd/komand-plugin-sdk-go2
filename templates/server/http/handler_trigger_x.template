package http

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
	"fmt"
	"encoding/json"
    "io/ioutil"
    "net/http"

    "{{ .PackageRoot }}/connection"
    "{{ .PackageRoot }}/triggers"
    plog "github.com/komand/plugin-sdk-go2/log"
    "github.com/komand/plugin-sdk-go2/message"
)

// {{ .Name }}TriggerHandler is a handler
type {{ .Name }}TriggerHandler struct {
	c *connection.Cache
}

// New{{ .Name }}TriggerHandler returns a new {{ .Name }}Handler
func New{{ .Name }}TriggerHandler(c *connection.Cache) *{{ .Name }}TriggerHandler {
	return &{{ .Name }}TriggerHandler{
		c: c,
	}
}

// ServeHTTP handles the requests
func (h *{{ .Name }}TriggerHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	response := &message.Response{
		Meta: []byte(`{}`),
		Status: "ok",
	}
	b, err := ioutil.ReadAll(r.Body)
	// TODO use a limit reader to prevent resource attacks?
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, "trigger_event", err)
		return
	}
	r.Body.Close()
	if r.Method != "POST" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		replyWithError(response, w, "trigger_event", fmt.Errorf("method %s is unsupported for plugin triggers", r.Method))
		return
	}
	body := &message.BodyV1{}
	m := &message.V1{
		Body: &body,
	}
	if err := json.Unmarshal(b, m); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		replyWithError(response, w, "trigger_event", err)
		return
	}
	// Unmarshal the body into the right struct
	// We could avoid the 2 excess json marshal calls in here with a lot of switch-casing on types
	// but in this case, the performance gain is not that great, and it's less generator code to maintain
	// to do it this way.
	// TODO if we suspect this is a bottleneck, profile it and swap back to the switch-case approach
	input := &triggers.{{ .Name }}TriggerInput{}
	if err := json.Unmarshal(body.Input, input); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, "trigger_event", err)
        return
	}
	// Each request needs a new logger to capture it's output
	// TODO move this to a sync.Pool and grab one from there each time to save on allocs?
	// note to anyone reading this: Do not go adding in sync.Pool without understanding how they
	// work and how to profile to see if adding one will actually make a difference :) It's tricky iirc.
	// Thats why this is a TODO and not a TODONE
	l := plog.NewBufferedLogger()
	for _, err = range input.Validate(l) {
        log.Println(fmt.Sprintf("Error while validating {{ .Name }}Input: %s", err.Error()))
	}
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, "trigger_event", fmt.Errorf("Error while validating {{ .Name }}Input. Check logs for details"))
        return
	}
	cd := &connection.Data{}
	if err := json.Unmarshal(body.Connection, cd); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, "trigger_event", err)
        return
	}

    conn, err := h.c.Get(cd, l)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
		response.Log = l.String()
		replyWithError(response, w, "trigger_event", err)
        return
    }

	trigger := triggers.{{ .Name }}Trigger{}
	output := &triggers.{{ .Name }}TriggerOutput{}
	if strings.HasSuffix(r.URL.String(), "test") {
		output, err = trigger.Test(conn, input, l)
	} else {
		// Triggers can ONLY be tested via proxy, never invoked
		w.WriteHeader(http.StatusBadRequest)
		replyWithError(response, w, "trigger_event", err)
		return
	}
	
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, "trigger_event", err)
		return
	}
	response.Log = l.String()
	response.Output = output
	reply := message.V1{
		Type: "trigger_event",
		Version: "v1",
		Body: response,
	}
	b, _ = json.Marshal(reply) // There is nothing we can do if this errs?
	w.WriteHeader(http.StatusOK)
	w.Write(b)
}