package http

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
	"fmt"
	"encoding/json"
    "io/ioutil"
    "net/http"

    "{{ .PackageRoot }}/actions"
    "{{ .PackageRoot }}/connection"
    plog "github.com/komand/plugin-sdk-go2/log"
    "github.com/komand/plugin-sdk-go2/message"
)

// {{ .Name }}Handler is a handler
type {{ .Name }}Handler struct {
	c *connection.Cache
}

// New{{ .Name }}Handler returns a new {{ .Name }}Handler
func New{{ .Name }}Handler(c *connection.Cache) *{{ .Name }}Handler {
	return &{{ .Name}}Handler{
		c: c,
	}
}

// ServeHTTP handles the requests
func (h *{{ .Name }}Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	m := message.V1{
		Status: "ok",
	}
	b, err := ioutil.ReadAll(r.Body)
	// TODO use a limit reader to prevent resource attacks?
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, err)
		return
	}
	r.Body.Close()
	if r.Method != "POST" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		replyWithError(response, w, fmt.Errorf("method %s is unsupported for plugin actions", r.Method))
		return
	}
	m := &message.V1{}
	if err := json.Unmarshal(b, m); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		replyWithError(response, w, err)
		return
	}
	// Unmarshal the body into the right struct
	// We could avoid the 2 excess json marshal calls in here with a lot of switch-casing on types
	// but in this case, the performance gain is not that great, and it's less generator code to maintain
	// to do it this way.
	// TODO if we suspect this is a bottleneck, profile it and swap back to the switch-case approach
	input := &actions.{{ .Name }}Input{}
	if err := json.Unmarshal(m.Body.Input, input); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, err)
        return
	}
	cd := &connection.Data{}
	if err := json.Unmarshal(m.Body.Connection, cd); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, err)
        return
	}
	l := plog.NewBufferedLogger()
    conn, err := h.c.Get(cd, l)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
		response.Log = l.String()
		replyWithError(response, w, err)
        return
    }
	// Each request needs a new logger to capture it's output
	// TODO move this to a sync.Pool and grab one from there each time to save on allocs?
	// note to anyone reading this: Do not go adding in sync.Pool without understanding how they
	// work and how to profile to see if adding one will actually make a difference :) It's tricky iirc.
	// Thats why this is a TODO and not a TODONE
	action := actions.{{ .Name }}Action{}
	output, err := action.Run(conn, input, l)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		replyWithError(response, w, err)
		return
	}
	response.Log = l.String()
	response.Output = output
	wrapper := &message.V1{
		Body: response,
		Type: "action_start",
		Version: "v1",
	}
	b, _ = json.Marshal(wrapper) // There is nothing we can do if this errs?
	w.WriteHeader(http.StatusOK)
	w.Write(b)
}